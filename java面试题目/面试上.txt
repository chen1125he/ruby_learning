http://www.importnew.com/22083.html

5.s1+1结果会是int，赋值给short会有问题
	s1 += 1隐含一个强制转换
6.没有goto但是是保留字
7.基本类型有包装类型(引用类型)
	Integer a = 3;
	int b = 3;
	a == b // true
	Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;
	如果 -128 <= Integer <= 127那么
	f1 == f2 //true
	f3 == f4 //false
8.&&和&/|和||
	&按位与
	&&短路运算(炒鸡强大)
	
9.栈，堆，静态区
	一个基本数据类型的变量、对象的引用还有函数调用的现在都使用栈空间;通过new关键字+构造器创建的对象放在堆空间;字面变量如直接书写的100，'hello'放在静态区
	String str = new String("Hello");
	str栈/new String()堆/"Hello"静态区
10.Math.floor()向下取整
	Math.round()四舍五入其实就是floor(num+0.5),负数也是+0.5
	ceil()是不小于它的最小整数
11.switch
	java5(不包括)前只能是byte short char int
	java5引入枚举
	java7可以String
12.用最有效率的方法计算2*8
	2 << 3 => 2 * (2 ^ 3)
	
13.数组没有length()方法，有length属性
	String有length()方法
	
14.跳出多重循环
	OK:
	for(...){
		for(...){
			if(..){
				break OK;	//标记设置在循环体开头，跳出设置的循环体
			}
		}
	}
	
15.构造器不能被继承，因而也不能被重写，但可以被重载
	
16.x.equals(y) == true那么他们的hash code应当相同(对象相同,hash_code相同)，hash_code相同，对象不一定相同
17.String是final类，不能被继承
18.java对象做参数是值传递，没有引用传递
19.String是只读、StringBuilder和StringBuffer是相同的
	String str1 = "this "+" is " + "string"  => String str1 = "this is string"两者是一样的 但如果把它们分成多个String对象相加就不一样了
	String > StringBuffer > StringBuilder(单线程) (处理速度)
	线程扩展 线程可以继承自Thread 或者接口Rubnnable(可以资源共享)
	
20.重写要求和父类有相同返回类型
	不同的返回类型不能用来作为重载条件的原因是，不能唯一确定一个方法
		比方说在单独调用一个fun()的时候，如果有两个fun() 一个返回int 一个返回void你不能确定这调用的是哪个方法
21.	
22.char 类型占2个字节，储存一个汉字是ok的
23.抽象类不能实例化，但必须把方法都实现，除非子类也是抽象类
24.静态方法中调用内部类会有错误
	如果想要的话，可以先new 一个外部类的实例再去调用内部类new Outer().new Inner();
25.java虽有垃圾回收机制，但也会存在存泄露
	像Hibernate 中的Session ,会存在无用但可达的垃圾对象，需要及时关闭或者清空(close or flush)
26.抽象的方法不能是静态的，因为静态的方法不能被重写
27.静态变量是被static修饰的变量，也叫做类变量，不属于任何一个对象，静态变量只有一个拷贝
	实例变量需要先创建对象才能访问到
	
28.静态方法只能访问静态成员，非静态方法有调用要先创建对象(成员方法应该也可以用类来调用类方法吧)
	
29.实现对象的克隆
	现有的clone()会对对象关联的一些引用照搬，clonePerson.getCar().setBrand('new Brand')/原person里面car的也会改变
	深度克隆要对象实现Serializable接口，通过序列化和反序列化实现克隆
		ByteArrayOutputStream bout = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bout);
        oos.writeObject(obj);
 
        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bin);
        return (T) ois.readObject();
30.GC是垃圾手机的意思，可以防止内存泄露，有效地使用可以使用的内存
31.String s = new String('xyz');
	创建了两个对象 一个是静态区的'xyz'，一个是new 创建在堆上的对象
32.接口可以继承接口，抽象类可以实现接口，接口可以继承具体类也可以继承抽象类
33.一个.java源文件可以包含多个类，但只能有一个public类而且必须和文件名完全一致
34.Anonymous Inner Class（匿名内部类）可以继承其他类或者实现其他接口
35.一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员
36.final修饰类表示其不能被继承，修饰方法表示不能被重写，修饰变量表示其只能被赋值一次
37.创建对象时候构造器的调用顺序是:先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器
	37的代码需要运行
38.字符串转化为基本数据类型调用对应【包装类】中的方法parseXX(String)或者valueOf(String)
	基本数据类型转字符串(String中的valueOf())或者与空串相连
39.需要去敲代码
40.怎样将GB2312编码的字符器转换为ISO-8859-1编码
	String s = new String(str.getBytes("GB2312"), "ISO-8859-1")
41.日期和时间
	Calendar cal = Calendar.getInscance();
	cal.get(Calendar.YEAR)
	cal.get(Calendar.MONTH)
	cal.get(Calendar.DATE)
	cal.get(Calendar.HOUR_OF_DAY)
	cal.get(Calendar.MINUTE)
	cal.get(Calendar.SECOND)
	
	获取毫秒数Calendar.getInstance().getTimeInMillis();
	cal.getActualMaximum(Clendar.DAY_OF_MONTH);
	
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");
	sdf.format(new Date());